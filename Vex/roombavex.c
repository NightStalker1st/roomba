#pragma config(UART_Usage, UART1, User_Control)
#pragma config(UART_Usage, UART2, User_Control)
#pragma config(Sensor, in4,    sonar,              sensorGeneric)
// Uncomment the 3rd #pragma line above for the Virtual Worlds simulator, comment it for Vex HW
// Also, uncomment one of the following two lines depending on whether you're compiling
// for Vex Coretex or Virtual Worlds Simulator
//#define VEX
#define Simulator
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
 * roombalib -- Roomba C API
 *
 * http://hackingroomba.com/
 *
 * Copyright (C) 2006, Tod E. Kurt, tod@todbot.com, Paul Bouchier
 *
 *  This program is heavily based on roombalib.c by Tod Kurt.
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General
 *  Public License along with this library; if not, write to the
 *  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 *  Boston, MA  02111-1307  USA
 *
 * Updates:
 * 14 Dec 2006 - adde d more functions to roombalib
 * 24 Nov 2010 - ported to Vex
 * 26 Feb 2011 - Removed notes about compiler bugs worked around. They are in svn version 197.
 * 11 March 2011 - Added bumpTurn capability, and rearranged buttons.
 */

/*

How to use program:
- Connect serial cable from coretex controller to roomba.
- When game controller & vex coretex controller have synced up, you must
put roomba into remote control mode.
- If you are using uartTwo, press B7R to select. (By default, uartOne is selected)
- Press B7L to put roomba 400 series into remote control mode. Press B7U to put
500 series roomba into remote control mode .It plays a little tune. If the tune
doesn't play, it isn't in remote control mode. Check your connections & baud rate.
- Once roomba is in remote control mode you can drive it with right joystick.
- Other functions:
  - B8R selects the autonomous program and B6U runs it
  - B8D turns vacuum motors on/off

TODO
- make auto-baudrate setting work
- make reading create sensors work

*/

#include "roombavex.h"

Roomba roomba;   // roomba is a pointer to the struct
unsigned byte cmd[20];
unsigned byte sensor_bytes[26];

/*
* Button assignment
Ch1XmCh1 (right joystici X axis) steers roomba
Ch2 (right joystick Y axis) controls fwd/back
Btn7L (left on left cross) connect to Roomba @ 57600 baud (Roomba 400 series)
Btn7U (upper on left cross) connect @ 115200 baud
Btn7D (lower on left cross) sets uart1 on controller (default)
Btn7R (right on left cross) sets uart2 on controller
Btn8D (lower on right cross) toggles vaccum motors on/off
Btn8R (right on right cross) selects autonomous pattern and beeps with pattern number
Btn8L (left on right cross) plays a tune
Btn6U (upper) runs autonomous_pattern (default is bumpTurn)
*/

#if defined(VEX)
/********************************************************************
 * compiling for Vex hardware                                       *
 ********************************************************************/
// main(), roomba_init(), roomba_drive(), roomba_send() for Vex


task main()
{
  int speed, radius, turn_value;
  int autonomous_pattern = 2;
  bool driving = false;
  bool vacuumOn = false;

  roomba.velocity = 100;

  configureSerialPort(uartOne, uartUserControl);
  setBaudRate(uartOne, baudRate115200);
  configureSerialPort(uartTwo, uartUserControl);
  setBaudRate(uartTwo, baudRate115200);
  roomba.fd = uartOne;
  writeDebugStream("RoombaVex start\n");

// loop forever getting the joystick & button values & acting on them
  while(true) {

// drive joystick
    // normalize speed & radius to Roomba special values
    speed = vexRT[Ch2] * 4;  // speed is 40 - 500mm/s (roomba caps at 500)
    if (abs(speed) < 80)
      speed = 0;

    turn_value = (vexRT[Ch1] * 16); // radius is 1 - 2048 or 32768 for straight
    radius = turn_value;
    if (radius > 0) {
      radius = radius - 1700;
      if (radius > 0)
        radius = -1;
    } else {
      radius = 1700 + radius;
      if (radius < 0)
        radius = 1;
  }

  // decide whether to drive
    if (abs(speed) > 40) {
      roomba_drive(speed, radius);
      writeDebugStream("drive %d %d\n", speed, radius);
      driving = true;
      roomba_delay(200);  // drive for 200ms
    } else {
      if (driving == true) {
        roomba_drive(0, 0);
        roomba_delay(COMMANDPAUSE_MILLIS);
        driving = false;    // issue the stop command once
      }
    }

// uartOne button
    if (vexRT[Btn7D] == 1) {
      writeDebugStream("uartOne selected\n");
      roomba.fd = uartOne;
      do {
        roomba_delay(500);  // wait for button release
      } while (vexRT[Btn7D] == 1);
  }

// uartTwo button
    if (vexRT[Btn7R] == 1) {
      writeDebugStream("uartTwo selected\n");
      roomba.fd = uartTwo;
      do {
        roomba_delay(500);  // wait for button release
      } while (vexRT[Btn7R] == 1);
  }

// connect roomba400 button
    if (vexRT[Btn7L] == 1) {
      writeDebugStream("57600 baud\n");
      roomba.baud_rate = baudRate57600;
      setBaudRate(roomba.fd, baudRate57600);
      roomba_init();
      do roomba_delay(500);  while (vexRT[Btn7L] == 1);
  }

// connect roomba500 button
    if (vexRT[Btn7U] == 1) {
      writeDebugStream("115200 baud\n");
      roomba.baud_rate = baudRate115200;
      setBaudRate(roomba.fd, baudRate115200);
      roomba_init();
      do {
        roomba_delay(500);  // wait for button release
      } while (vexRT[Btn7U] == 1);
    }

// select autonomous pattern
    if (vexRT[Btn8R] == 1) {
      autonomous_pattern++;
      if (autonomous_pattern > MAX_PATTERNS)
        autonomous_pattern = 1;
      wait_button_release(Btn8R);
      roomba_beep(autonomous_pattern);
    }

// autonomous go button
    if (vexRT[Btn6U] == 1) {
      wait_button_release(Btn6U);
      writeDebugStream("auto %d\n", autonomous_pattern);
      autonomous_go(autonomous_pattern);
  }

// Toggle vacuum motors button
    if (vexRT[Btn8D] == 1) {
      if (vacuumOn == false) {
        vacuumOn = true;
        roomba_vacuum(true);
      } else {
        vacuumOn = false;
        roomba_vacuum(false);
      }
      // wait until button is released
      while (vexRT[Btn8D] == 1) {
        roomba_delay(100);
      }
    }

// Test function button
    if (vexRT[Btn8L] == 1) {
      play_giddyup();
      // wait until button is released
      while (vexRT[Btn8L] == 1) {
        roomba_delay(500);
      }
    }
    roomba_delay(COMMANDPAUSE_MILLIS);
  }
}

void roomba_init()
{
    int n;

    roomba.velocity = DEFAULT_VELOCITY;

    writeDebugStream("roomba_init\n");
    cmd[0] = 128;      // START
    roomba_send(roomba.fd, 1);    // send from cmd buffer
    roomba_delay(COMMANDPAUSE_MILLIS);

    cmd[0] = 130;   // CONTROL
    roomba_send(roomba.fd, 1);
    roomba_delay(COMMANDPAUSE_MILLIS);

    n = roomba_read_sensors();

		if (n == 26) {
		  //roomba.baud_rate = baudRate115200;
    // play the high "I woke up" tune
      roomba_play_note(82, 10);
		  roomba_delay(200);
		  roomba_play_note(89, 10);
		  roomba_delay(200);
		  roomba_play_note(86, 10);
		  roomba_delay(200);
		}
}

void wait_button_release(int button)
{
    do {
      roomba_delay(COMMANDPAUSE_MILLIS);
    } while (vexRT[button] == 1);
}

int check_for_button(int button)
{
  if (vexRT[button] == 1)
    return 1;
  else
    return 0;
}

// send an arbitrary length roomba command
int roomba_send(TUARTs uartNum, int len )
{
    for (int i=0; i<len; i++) {
      sendChar(uartNum, cmd[i]);
    }
    return 0; // indicate error, can usually ignore
}

// Move Roomba with low-level DRIVE command
void roomba_drive(int velocity, int radius )
{
    uint8_t vhi = velocity >> 8;
    uint8_t vlo = velocity & 0xff;
    uint8_t rhi = radius   >> 8;
    uint8_t rlo = radius   & 0xff;
    cmd[0] = 137;   // DRIVE
    cmd[1] = vhi;
    cmd[2] = vlo;
    cmd[3] = rhi;
    cmd[4] = rlo;
    roomba_send(roomba.fd, 5);
}

// read all roomba sensors into sensor_bytes array & return # of bytes read
int roomba_read_sensors()
{
    short s;
    int i;

    cmd[0] = 142;
    cmd[1] = 0;          // SENSOR, get all sensor data
    roomba_send( roomba.fd, 2);
    roomba_delay(SENSOR_DELAY);
    ClearTimer(T1);
    i = 0;
    do {
      s=getChar(roomba.fd);
      if (s < 0x100) {  // 0x100 = no character
        sensor_bytes[i] = s;
        i++;
      }
      roomba_delay(1);
    } while ((i < 26) && (time1[T1] < 1000));
    return i;
}


#endif
/********************************************************************
 * compiling for planet H99 simulator                               *
 ********************************************************************/
// main(), roomba_drive() for H99 simulator
#if defined(Simulator)

task main()
{
  roomba.velocity = 100;

  bumpTurn();
}

void wait_button_release(int button)
{
    return;
}

int check_for_button(int button)
{
  return 0;
}

void roomba_drive( int velocity, int radius )
{
  int v, r;
  writeDebugStream("roomba_drive\n");
  if (velocity > 100)      // roomba velocity can go up to 500mm/s, vex only to 100
    v = 100;
  else
    v = velocity;
  if (abs(radius) > 200)
    r = 32768;
  else
    r = radius;

  if (r == 1) { // spin left
    motor[port2] = -v;
    motor[port3] = v;
  } else if (r == -1) {  // spin right
    motor[port2] = v;
    motor[port3] = -v;
  } else {
    motor[port2] = v;
    motor[port3] = v;
  }
}

int roomba_send(int uartNum, int len)
{
  writeDebugStream("roomba_send\n");
  return 0;
}

void roomba_init() { }

int roomba_read_sensors()
{
  int sonarValue;

  sonarValue = SensorValue(sonar);
  writeDebugStream("read_sensors\n");
  if((sonarValue < SONAR_THRESHOLD) && (sonarValue != -1)) {
    sensor_bytes[BUMPSWHEELDROPS] = BUMP_MASK;  // indicate the bump sensor has been hit
    writeDebugStream("sonar at %d\n", sonarValue);
  } else {
    sensor_bytes[BUMPSWHEELDROPS] = 0;
  }
  return 26;
}

#endif

void roomba_delay( int millisecs )
{
    wait1Msec(millisecs);
}

#if 1
// state machine version of bumpTurn
void bumpTurn()
{
  int i;
  char bumpSide;
  int angle;
  int bumpTurnSmState = 0;
  int endMotionTime = FWD_MAX_TIME10;   // when to stop going forward
  int time = 0;   // synthesize my own 10ms clock, since time1[] doesn't work
  //ClearTimer(T1);

  while(1) {
    roomba_delay(10);   // synthesize a 10ms clock
    time++;
    if (time > MAX_10MS) {   // don't let timer count above MAX_10MS
      time = 0;
      //ClearTimer(T1);
    }

    // check if we bumped into anything, and if so, turn away
    //writeDebugStream("rd sensors at %d\n", time1[T2]);
    i = roomba_read_sensors();
    if (i != 26) {
      writeDebugStream("Sensor error %d\n", i);
  }

    switch (bumpTurnSmState) {
    case 0:   // going forward for timed duration before spinning around
      roomba_forward();
      if (bumpLeft()) {
        roomba_stop();
        bumpSide = 'L';
        bumpTurnSmState = 2;
      } else if (bumpRight()) {
        roomba_stop();
        bumpSide = 'R';
        bumpTurnSmState = 2;
      } else if (time == endMotionTime) {  // reached end of fwd motion time, do surveillance
        bumpTurnSmState = 1;
        writeDebugStream("Surveillance at %d\n", time);
        roomba_stop();
        roomba_delay(STOP_TIME);
      } else if (check_for_button(Btn6U)) {     // stop & exit if Btn6U pressed
        roomba_stop();
        wait_button_release(Btn6U);
        return;
      }
      break;

    case 1:   // stop & do surveillance by spinning around looking
      for (i=0; i<3; i++) {
        roomba_spinleft_degrees(90);
        roomba_stop();
        roomba_delay(SURVEILLANCE_PAUSE);
      }
      //roomba_spinleft_degrees(90);
      bumpTurnSmState = 0;  // go straight again
      endMotionTime = time + FWD_MAX_TIME10;
      i = normalize10ms(endMotionTime);
      endMotionTime = i;
      writeDebugStream("%d: end at %d\n", time, endMotionTime);
      break;

    case 2:   // hit obstacle, back up & turn
      roomba_stop();
      roomba_delay(STOP_TIME);
      roomba_backward();
      roomba_delay(BACKUP_TIME);
      roomba_stop();
      angle = random(100) + SPIN_MIN;
      if (bumpSide == 'L') {
        roomba_spinright_degrees(angle);
      } else {
        roomba_spinleft_degrees(angle); // spin a random ammount between 30 & 180 degrees
      }
      roomba_stop();
      roomba_delay(STOP_TIME);

      bumpTurnSmState = 0;  // go forward again
      endMotionTime = time + FWD_MAX_TIME10;      // set the surveillance timer running again
      i = normalize10ms(endMotionTime);
      endMotionTime = i;
      writeDebugStream("%d: end at %d\n", time, endMotionTime);
      break;

    default:
      bumpTurnSmState = 0;  // should never get here
      writeDebugStream("Error: default\n");
    }
  }
}

#else
// procedural version of bumpTurn; doesn't have surveillance mode

int stopBack()
{
  int angle;

  roomba_stop();
  roomba_delay(STOP_TIME);
  roomba_backward();
  roomba_delay(BACKUP_TIME);
  roomba_stop();
  angle = random(100) + SPIN_MIN;
  return angle;

}

// procedural version of bumpTurn
void bumpTurn()
{
  int angle;

  //ClearTimer(T2);

  do {
    // check if we bumped into anything, and if so, turn away
    //writeDebugStream("rd sensors at %d\n", time1[T2]);
    roomba_read_sensors();
    //writeDebugStream("end sens rd %d\n", time1[T2]);

    if (bumpLeft()) {
      //writeDebugStream("bumpLeft at %d\n", time1[T2]);
      angle = stopBack();
      roomba_spinright_degrees(angle); // spin a random ammount between 30 & 180 degrees
      roomba_stop();
      roomba_delay(STOP_TIME);
    } else if (bumpRight()) {
      //writeDebugStream("bumpRight at %d\n", time1[T2]);
      angle = stopBack();
      roomba_spinleft_degrees(angle); // spin a random ammount between 30 & 180 degrees
      roomba_stop();
      roomba_delay(STOP_TIME);
    } else {
      roomba_forward();
    }
    //writeDebugStream("end loop at %d\n", time1[T2]);
    //roomba_delay(1000);
  } while (check_for_button(Btn6U) == 0);
  roomba_stop();
  //wait_button_release(Btn6U);
}
#endif

void autonomous_go(int pattern)
{
  // patterns are responsible for deciding when to finish or stop
  writeDebugStreamLine("pattern %d", pattern);
    if (pattern == 1)
      pattern1();
    if (pattern == 2)
      bumpTurn();
}

// do the herky-jerky pattern
void pattern1()
{
    int motion_time = 2000;

    roomba_set_leds(1, 1, 1, 1, 1, 1, 127, 127);

    roomba_set_velocity(DEFAULT_VELOCITY);
    roomba_get_velocity();

    roomba_forward();
    roomba_delay(motion_time);
    roomba_stop();
    roomba_delay(500);

    roomba_forward_at(500);
    roomba_delay(motion_time);
    roomba_stop();
    roomba_delay(500);

    roomba_backward();
    roomba_delay(motion_time);
    roomba_stop();
    roomba_delay(500);

    roomba_backward_at(500);
    roomba_delay(motion_time);
    roomba_stop();
    roomba_delay(500);

    roomba_spinleft();
    roomba_delay(motion_time);
    roomba_stop();
    roomba_delay(500);

    roomba_spinleft_at(500);
    roomba_delay(motion_time);
    roomba_stop();
    roomba_delay(500);

    roomba_spinright();
    roomba_delay(motion_time);
    roomba_stop();
    roomba_delay(500);

    roomba_spinright_at(500);
    roomba_delay(motion_time);
    roomba_stop();
    roomba_delay(500);

    roomba_spinright_degrees(90);
    roomba_stop();
    roomba_delay(500);
    roomba_spinleft_degrees(90);
    roomba_stop();
    roomba_delay(500);

    play_giddyup();

    roomba_vacuum(1);
    roomba_delay(motion_time);
    roomba_vacuum(0);
    roomba_delay(COMMANDPAUSE_MILLIS);

    roomba_read_sensors();
    bumps_wheeldrops();
    cliff_left();
    cliff_frontleft();
    cliff_frontright();
    cliff_right();
    bump();
    bumpLeft();
    bumpRight();
    wheelDropLeft();
    wheelDropRight();
    wheelDropCenter();
    wall();
}

void play_giddyup()
{
    roomba_play_note(72, 10); // C
    roomba_delay(100);
    roomba_play_note(72, 10); // C
    roomba_delay(100);
    roomba_play_note(72, 10); // C
    roomba_delay(100);
    roomba_play_note(78, 20); // C
    roomba_delay(200);
    roomba_play_note(72, 10); // C
    roomba_delay(100);
    roomba_play_note(72, 10); // C
    roomba_delay(100);
    roomba_play_note(78, 20); // C
    roomba_delay(100);

}

void roomba_beep(int beep_cnt)
{
   int i;
   for (i=0; i<beep_cnt; i++) {
     roomba_play_note(78, 10);
     roomba_delay(300);
   }
}

/*
Roomba library functions
*/

void roomba_stop()
{
    roomba_drive( 0, 0 );
}

void roomba_set_velocity( int velocity )
{
    roomba.velocity = velocity;
}

int roomba_get_velocity()
{
    return roomba.velocity;
}

void roomba_forward()
{
    roomba_drive( roomba.velocity, 0x8000 );  // 0x8000 = straight
}
void roomba_forward_at( int velocity )
{
    roomba_drive( velocity, 0x8000 );
}

void roomba_backward()
{
    roomba_drive( -roomba.velocity, 0x8000 );
}
void roomba_backward_at(int velocity )
{
    roomba_drive( -velocity, 0x8000 );
}

void roomba_spinleft()
{
    roomba_drive( roomba.velocity, 1 );
}
void roomba_spinleft_at( int velocity )
{
    roomba_drive( velocity, 1 );
}
void roomba_spinleft_degrees( int degrees )
{
    /*
     * delay in ms = (2.25mm/degree * angle / speed (mm/s)) * 1000 ms/s
     * For speed 128, delay in ms ~= angle * 9
     * so we use angle << 4 to allow for ramp up/down
     */
    roomba_spinleft_at(DEFAULT_VELOCITY);
    roomba_delay(degrees << ANGLE_TO_TIME);
}

void roomba_spinright()
{
    roomba_drive( roomba.velocity,  -1 );
}
void roomba_spinright_at( int velocity )
{
    roomba_drive( velocity,  -1 );
}
void roomba_spinright_degrees( int degrees )
{
    roomba_spinright_at(DEFAULT_VELOCITY);
    roomba_delay(degrees << ANGLE_TO_TIME);
}

void roomba_play_note( uint8_t note, uint8_t duration )
{
    cmd[0] = 140;
    cmd[1] = 1;
    cmd[2] = 1;
    cmd[3] = note;
    cmd[4] = duration; // SONG, then
    cmd[5] = 141;
    cmd[6] = 1;       // PLAY
    roomba_send(roomba.fd, 7);
}

// Turns on/off the non-drive motors (main brush, vacuum, sidebrush).
void roomba_set_motors( uint8_t mainbrush, uint8_t vacuum, uint8_t sidebrush)
{
    cmd[0] = 138;       // MOTORS
    cmd[1] = ((mainbrush?0x04:0)|(vacuum?0x02:0)|(sidebrush?0x01:0));
    roomba_send( roomba.fd, 2);
}

// Turns on/off the various LEDs.
void roomba_set_leds( uint8_t status_green, uint8_t status_red,
                      uint8_t spot, uint8_t clean, uint8_t max, uint8_t dirt,
                      uint8_t power_color, uint8_t power_intensity )
{
    uint8_t v = (status_green?0x20:0) | (status_red?0x10:0) |
                (spot?0x08:0) | (clean?0x04:0) | (max?0x02:0) | (dirt?0x01:0);
    cmd[0] = 139;
    cmd[1] = v;
    cmd[2] = power_color;
    cmd[4] = power_intensity; // LEDS
    roomba_send( roomba.fd, 4);
}

// Turn all vacuum motors on or off according to state
void roomba_vacuum( uint8_t state ) {
    roomba_set_motors( state,state,state);
}

    //
    // lower-level sensor access
    //
    /** lower-level func, returns raw byte */
int bumps_wheeldrops() {
        return sensor_bytes[BUMPSWHEELDROPS];
    }
    /** lower-level func, returns raw byte */
int cliff_left() {
        return sensor_bytes[CLIFFLEFT];
    }
    /** lower-level func, returns raw byte */
int cliff_frontleft() {
        return sensor_bytes[CLIFFFRONTLEFT];
    }
    /** lower-level func, returns raw byte */
int cliff_frontright() {
        return sensor_bytes[CLIFFFRONTRIGHT];
    }
    /** lower-level func, returns raw byte */
int cliff_right() {
        return sensor_bytes[CLIFFRIGHT];
    }

    /** Did we bump into anything */
int bump() {
        return (sensor_bytes[BUMPSWHEELDROPS] & BUMP_MASK) !=0;
    }
    /** Left bump sensor */
int bumpLeft() {
        return (sensor_bytes[BUMPSWHEELDROPS] & BUMPLEFT_MASK) !=0;
    }
    /** Right bump sensor */
int bumpRight() {
        return (sensor_bytes[BUMPSWHEELDROPS] & BUMPRIGHT_MASK) !=0;
    }
    /** Left wheeldrop sensor */
int wheelDropLeft() {
        return (sensor_bytes[BUMPSWHEELDROPS] & WHEELDROPLEFT_MASK) !=0;
    }
    /** Right wheeldrop sensor */
int wheelDropRight() {
        return (sensor_bytes[BUMPSWHEELDROPS] & WHEELDROPRIGHT_MASK) !=0;
    }
    /** Center wheeldrop sensor */
int wheelDropCenter() {
        return (sensor_bytes[BUMPSWHEELDROPS] & WHEELDROPCENT_MASK) !=0;
    }
    /** Can we see a wall? */
int wall() {
        return sensor_bytes[WALL_DETECT] != 0;
    }
